<!DOCTYPE html>
<html lang="en">
<head>
    <script src="../Scripts/jquery-1.10.2.min.js"></script>
    <script src="../Scripts/bootstrap.min.js"></script>
    <script src="../Scripts/bootstrap-datepicker.min.js"></script>
    <script src="apiGet.js"></script>
    <script src="../Scripts/bootstrap-slider.min.js"></script>
    <!-- Use correct character set. -->
    <meta charset="utf-8">
    <!-- Tell IE to use the latest, best version. -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <title>Hello World!</title>
    <script src="cesium/Build/Cesium/Cesium.js"></script>
    <style>
        @import url(cesium/Build/Cesium/Widgets/widgets.css);
        @import url(bootstrap.css);
        .cesium-viewer-bottom {
            display: none;
        }
        html, body, #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .slider-horizontal {
            height: 10px;
        }
    </style>
    <script>
        var viewer = null;
        function refreshLaunches()
        {
            var from = $("#datefrom").val();
            var to = $("#dateto").val();
            getLaunchesForDateRange(from, to, drawLaunches);
        }
        function lll(lon, lat, height, T)
        {
            V = Math.sqrt(6.67 * 5.97 * Math.pow(10, 13) / (6371 * 1000 + height));
            var W = V / 6371 / 1000 / 3.141592 * 180;
            curlon = lon + W * T;
            curlat = lat + W * T;
            return [curlon, curlat];
        }
        function angleFromCoordinate(lat1, long1, lat2,
            long2)
        {

            dLon = (long2 - long1);

            y = Math.sin(dLon) * Math.cos(lat2);
            x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1)
                * Math.cos(lat2) * Math.cos(dLon);

            brng = Math.atan2(y, x);
            brng = brng / 3.141592 * 180;
            brng = (brng + 360) % 360;
            brng = 360 - brng; // count degrees counter-clockwise - remove to make clockwise

            return brng;
        }

        function getOrbitThrough(long, lat)
        {
            var bestP = null;
            var bestD = 1000000000000;
            var bid = 0;
            var bestIncl;
            for (var inclination = -90; inclination < 90; inclination += 5)
            {
                var parogee = 400000;
                var appogee = 400000;
                var loan = 0;
                var argument_of_periapsis = 80;
                var coords = Cesium.Cartesian3.fromDegreesArrayHeights([long, lat, 0]);
                var mD = 1000000000000;
                var mi;

                var semi_major = parogee + appogee / 2;

                var e = 0;

                // altitude for minor vertix
                var semi_minor = semi_major * Math.sqrt(1 - Math.pow(e, 2));

                var inclination_m = Cesium.Matrix3.fromRotationY(-1 * Cesium.Math.toRadians(inclination));

                var raan_m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(loan));

                var aop_m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(argument_of_periapsis));

                var positions = [];

                for (var i = -180; i <= 160; i += 1)
                {
                    //r = a(1-e^2)/ 1+e\cos \theta}
                    var radius = semi_major * (1 - Math.pow(e, 2)) / (1 + e * Math.cos(Cesium.Math.toRadians(i)));

                    //create point
                    var p = new Cesium.Cartesian3.fromDegrees(i - 90, 0, radius);

                    //rotate around earth Y axis to apply inclination
                    var rotated = Cesium.Matrix3.multiplyByVector(inclination_m, p, new Cesium.Cartesian3());

                    //rotate around earth Z to apply RAAN
                    var raan = Cesium.Matrix3.multiplyByVector(raan_m, rotated, new Cesium.Cartesian3());

                    //rotate around orbit plane Z to apply AOP
                    //transform to local orbit plane
                    //??????
                    var final = Cesium.Matrix3.multiplyByVector(aop_m, raan, new Cesium.Cartesian3());

                    var D = Cesium.Cartesian3.distance(coords[0], final);
                    if (D < mD)
                    {
                        mD = D;
                        mi = i;
                    }
                    positions.push(final);
                }
                if (mD < bestD)
                {
                    bestP = positions;
                    bestD = mD;
                    bestIncl = inclination;
                    bid = mi;
                }
            }

            var inclination = bestIncl;
            var parogee = 400000;
            var appogee = 400000;
            var loan = 0;
            var argument_of_periapsis = 80;
            var coords = Cesium.Cartesian3.fromDegreesArrayHeights([long, lat, 0]);
            var dr = 0;
            var mD = 1000000000000;
            var mi;

            var semi_major = parogee + appogee / 2;

            var e = 0;

            // altitude for minor vertix
            var semi_minor = semi_major * Math.sqrt(1 - Math.pow(e, 2));

            var inclination_m = Cesium.Matrix3.fromRotationY(-1 * Cesium.Math.toRadians(inclination));

            var raan_m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(loan));

            var aop_m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(argument_of_periapsis));

            var positions = [];
            var dr = 5;
            for (var i = bid; i < 180; i += 0.1)
            {
                //r = a(1-e^2)/ 1+e\cos \theta}
                var radius = semi_major * (1 - Math.pow(e, 2)) / (1 + e * Math.cos(Cesium.Math.toRadians(i)));
                if (dr == 5)
                {
                    dr = -radius;
                }
                else
                {
                    dr += 2000;
                }
                if (dr > 0) dr = 0;
                //create point
                var p = new Cesium.Cartesian3.fromDegrees(i - 90, 0, radius + dr);

                //rotate around earth Y axis to apply inclination
                var rotated = Cesium.Matrix3.multiplyByVector(inclination_m, p, new Cesium.Cartesian3());

                //rotate around earth Z to apply RAAN
                var raan = Cesium.Matrix3.multiplyByVector(raan_m, rotated, new Cesium.Cartesian3());

                //rotate around orbit plane Z to apply AOP
                //transform to local orbit plane
                //??????
                var final = Cesium.Matrix3.multiplyByVector(aop_m, raan, new Cesium.Cartesian3());
                positions.push(final);
            }
            for (var i = -180; i < bid - 30; i += 0.1)
            {
                if (dr < 0) dr += 2000;
                if (dr > 0) dr = 0;
                //r = a(1-e^2)/ 1+e\cos \theta}
                var radius = semi_major * (1 - Math.pow(e, 2)) / (1 + e * Math.cos(Cesium.Math.toRadians(i)));
                //create point
                var p = new Cesium.Cartesian3.fromDegrees(i - 90, 0, radius + dr);

                //rotate around earth Y axis to apply inclination
                var rotated = Cesium.Matrix3.multiplyByVector(inclination_m, p, new Cesium.Cartesian3());

                //rotate around earth Z to apply RAAN
                var raan = Cesium.Matrix3.multiplyByVector(raan_m, rotated, new Cesium.Cartesian3());

                //rotate around orbit plane Z to apply AOP
                //transform to local orbit plane
                //??????
                var final = Cesium.Matrix3.multiplyByVector(aop_m, raan, new Cesium.Cartesian3());
                positions.push(final);
            }
            return positions;

        }
        function drawPath()
        {
            var positions = getOrbitThrough(63.31, 45.51);
            console.log(positions);
            var entity = viewer.entities.add({
                polyline: {
                    positions: positions,
                    followSurface: true,
                    width: 4,
                    material: Cesium.Color.RED
                }
            });

            viewer.zoomTo(viewer.entities);
        }

        function drawLaunches(launches)
        {
            for (launch in launches)
            {
                launch = launches[launch];
                var lat = launch.location.pads[0].latitude;
                var long = launch.location.pads[0].longitude;
                lat += Math.random() * 0.01
                long += Math.random() * 0.01
                console.log(launch);
                console.log(lat);
                console.log(long);
                var entity = viewer.entities.add({
                    position: Cesium.Cartesian3.fromDegrees(long, lat),
                    model: {
                        uri: 'rocket.glb',
                        minimumPixelSize: 40
                    }
                });
            }
        }
        $(document).ready(function ()
        {
            $(".datepicker").datepicker({ format: "yyyy-mm-dd", startDate: "01.01.1950." }).on("hide", function ()
            {
                refreshLaunches();
            });
            $("#datefrom").datepicker("setDate", "now");
            $("#dateto").datepicker("setDate", "+5d");
        });
        setTimeout(function ()
        {
            refreshLaunches();
        }, 2000);
    </script>
</head>
<body>
    <div id="cesiumContainer" style="width:80%;float:left"></div>
    <div id="menu" style="float:right;width:20%;">
        From date:<br />
        <input type="datetime" class="form-control datepicker" id="datefrom" /><br />
        To date:<br />
        <input type="datetime" class="form-control datepicker" id="dateto"/>
    </div>
    <script>
        viewer = new Cesium.Viewer('cesiumContainer',{
            timeline: false,
            animation: false,
            homeButton: false,

        });
    </script>
</body>
</html>
